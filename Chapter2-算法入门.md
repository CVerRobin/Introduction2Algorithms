# 第2章 算法入门
## 2.1 插入排序
第一个算法是插入排序算法。

**输入**：n个数($a_1,a_2,...,a_n$)。

**输出**：输入序列的一个排列（即重新排序）($a_1',a_2',...,a_n'$)，使得$a_1 \leq a_2'\leq...\leq a_n'$。

待排序的数也称为关键字(key)。

代码见：[Insertion-sort](./chapter2/Insertion-sort.cpp)

### 循环不变式与插入算法的正确性
循环不变式主要用来帮助我们理解算法的正确性。对于循环不变式，必须证明它的三个性质：

**初始化**：它在循环的第一轮迭代开始之前，应该是正确的。

**保持**：如果在循环的某一次迭代开始之前它是正确的，那么，下一次迭代开始之前她也应该保持正确。

**终止**：当循环结束时，不变式给了我们一个有用的性质，它有助于表明算法是正确的。

当头两个性质成立时，就能保证循环不变式在循环的每一轮迭代开始之前，都是正确的。

**证明**：

**初始化**：首先，先证明在第一轮迭代开始之前，循环不变式是成立的。此时j=2，而子数组为A[0..j-1]。亦即，它至包含一个元素A[0]，实际上就是最初在A[0]中的那个元素。显然这个子数组是已排序的，这样就证明了循环不变式的第一轮迭代开始之前是成立的。

**保持**：非形式化证明即，在外层for循环中，要将A[j-1]，A[j-2]，A[j-3]等元素向右移动一个位置，知道找到A[j]的位置为止，此时将A[j]插入。

**终止**：对于插入排序，当j>=n时，外层for循环技术。在循环不变式中，将j替换为n，就有子数组A[0..n-1]，包含了A[0..N-1]中元素，且已排好序。同时，子数组就是整个数组，因此，整个数组排好序了，这意味着算法是正确的。

### 练习
2.1-1 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的执行过程。

2.1-2 重写过程INSERTION-SORT，使之按非升序（而不是按降序）排列。

[Insertion-sort2.cpp](./chapter2/Insertion-sort2.cpp)

2.1-3 考虑下面的查找问题：

**输入**：一列数$A=<a_1,a_2,...,a_n>$和一个值v。

**输出**：下标i，使得v=A[i]，或者当v不在A中出现时为NIL。

写出针对这个问题的线性查找的伪代码，它顺序地扫描整个序列以查找v。利用循环不变式证明算法的正确性。确保所给出的循环不变式满足三个必要的性质。

[Find_value_in_array](./chapter2/Find_value_in_array.cpp)

2.1-4 有两个各存放在数组A和B中的n位二进制整数，考虑它们的相加问题。两个整数的和以二进制形式存放在具有(n+1)个元素的数组C中。清给出这个问题的形式化描述，并写出伪代码。

[BinarySum](./chapter2/BinarySum.cpp)

## 2.2 算法分析

算法分析即指对一个算法所需要的资源进行预测。通常我们希望预测的是计算时间。书中采用一种通用的但处理器、随机存取机（RAM）计算模型，在RAM模型中，指令一条接一条执行，没有并发操作。

### 插入排序算法的分析

**输入规模**的概念与具体问题有关，对许多问题而言，最自然的度量标准是输入中元素个数。
算法的**运行时间**是指在特定输入时，所执行的基本操作数（或步数）。

### 最坏情况和平均情况分析

一般考察算法的**最坏情况运行时间**，亦即，对于任何规模为n的任何输入，算法的最长运行时间。原因如下：

1. 一个算法的最坏情况时在任何输入下运行时间的上限。
2. 对于某些算法来说（例如：在数据库检索信息而信息并不在数据库中），最坏情况出现得相当频繁。
3. 大致上看，“平均情况”同拆毁嗯与最坏情况一样差。

在某些情况喜爱，我们会对算法的**平均情况**或**期望**的运行时间感兴趣，第5章会介绍**概率分析**技术来确定一个算法期望的运行时间。采用**随机化算法**可以做出随机选择，从而可以对算法进行概率分析。

### 增长的量级

运行时间的**增长率**（**增长的量级**），只需要考虑攻势中的最高次项且忽略其系数。例如插入排序的最坏情况时间代价为$\Theta(n^2)$

## 练习
2.2-1 用$\Theta$形式表示函数$n^3/1000-100n^2-100n+3$

$\Theta(n)$

2.2-2 考虑对数组A中的n个数进行排序的问题：首先找出A中的最小元素，并将其与A[1]中的元素进行交换。接着，找出A中的次小小于，并将其与A[2]中的元素进行交换。对A中头n-1个元素继续这一过程。写出这个算法的伪代码，该算法称为**选择排序**。对这个算法来说，循环不变式是什么？为什么它仅需要在头n-1个元素上运行，而不是在所有n个元素上运行？以$\Theta$形式写出选择排序的最佳和最坏情况下的运行时间

[Select-Sort](./chapter2/Select-Sort.cpp)

循环不变式是选择的for循环部分。因为每次是前后的元素比较，第n-1个元素与第n个比较。

最佳情况：$\Theta(1)$，最坏情况$\Theta(n^2)$

2.2-3 再次考虑线性查找问题（见习题2.1-3）。在平均情况下需要检查输入序列的多少个元素？假定待查找的元素是数组中任何一个元素的可能性是相等的。在最坏情况喜爱又怎样呢？用$\Theta$表示的画吗线性查找的平均情况和最坏情况怎样？对你的答案加以说明。

平均情况下查找$[\frac{n}{2}]$。最坏的情况下查找n个元素。平均与最坏都是$\Theta(n)$

2.2-4 应如何修改一个算法，才能使之具有良好的最佳情况运行时间？

尽量少用循环