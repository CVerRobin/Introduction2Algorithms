# 第2章 算法入门
## 2.1 插入排序
第一个算法是插入排序算法。

**输入**：n个数($a_1,a_2,...,a_n$)。

**输出**：输入序列的一个排列（即重新排序）($a_1',a_2',...,a_n'$)，使得$a_1<=a_2'<=...<=a_n'$。

待排序的数也称为关键字(key)。

代码见：[Insertion-sort](./Insertion-sort.cpp)

### 循环不变式与插入算法的正确性
循环不变式主要用来帮助我们理解算法的正确性。对于循环不变式，必须证明它的三个性质：

**初始化**：它在循环的第一轮迭代开始之前，应该是正确的。

**保持**：如果在循环的某一次迭代开始之前它是正确的，那么，下一次迭代开始之前她也应该保持正确。

**终止**：当循环结束时，不变式给了我们一个有用的性质，它有助于表明算法是正确的。

当头两个性质成立时，就能保证循环不变式在循环的每一轮迭代开始之前，都是正确的。

**证明**：

**初始化**：首先，先证明在第一轮迭代开始之前，循环不变式是成立的。此时j=2，而子数组为A[0..j-1]。亦即，它至包含一个元素A[0]，实际上就是最初在A[0]中的那个元素。显然这个子数组是已排序的，这样就证明了循环不变式的第一轮迭代开始之前是成立的。

**保持**：非形式化证明即，在外层for循环中，要将A[j-1]，A[j-2]，A[j-3]等元素向右移动一个位置，知道找到A[j]的位置为止，此时将A[j]插入。

**终止**：对于插入排序，当j>=n时，外层for循环技术。在循环不变式中，将j替换为n，就有子数组A[0..n-1]，包含了A[0..N-1]中元素，且已排好序。同时，子数组就是整个数组，因此，整个数组排好序了，这意味着算法是正确的。

### 练习
2.1-1 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的执行过程。

2.1-2 重写过程INSERTION-SORT，使之按非升序（而不是按降序）排列。

[Insertion-sort2.cpp](./Insertion-sort2.cpp)

2.1-3 考虑下面的查找问题：

**输入**：一列数$A=<a_1,a_2,...,a_n>$和一个值v。

**输出**：下标i，使得v=A[i]，或者当v不在A中出现时为NIL。

写出针对这个问题的线性查找的伪代码，它顺序地扫描整个序列以查找v。利用循环不变式证明算法的正确性。确保所给出的循环不变式满足三个必要的性质。

[Find_value_in_array](./Find_value_in_array.cpp)

2.1-4 有两个各存放在数组A和B中的n位二进制整数，考虑它们的相加问题。两个整数的和以二进制形式存放在具有(n+1)个元素的数组C中。清给出这个问题的形式化描述，并写出伪代码。

[BinarySum](./BinarySum.cpp)